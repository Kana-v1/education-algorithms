Characteristics of Algorithm:

1) Input - every algorightm has an input value (0+)

2) Output - every algorithm has to generate at least 1 output value

3) Definiteness - algorithm has to produce kind of final value (sqrt(4) is not a final value)

4) Finiteness - algorithm must stop at 1 moment (server does not)

5) Efectiness - ...


Criterias of an algorithm:

1) Time

2) Space

3) Network consumption (data transfer)

4) Power consumption

5) CPU Registers (if it is low level algorithm)

Algorithm effectiveness measures

 - Time analysis:  1 simple operation (aka +, -, =) gets 1 unit of time. Algorithm x = 5 * a + 6 * b will take 4 units of time (+, 2* and =) or 1 unit of time. It depends on the level of your point of analyze


 - Space analyzes: 1 unit(word) per assigning



Huffman algorithm allows to reduce a size of the message
How does it work: 
msg: ABCADDDD

1) calculate how many times each letter occur
A - 2
B - 1
C - 1
D - 4

2) Create an algorithm from the tree
		           8
		          /  \
        	0 /    \
		        /      \
	        4        \
	      /   \       \
  	   /	    \ 1     \   1
     /	      \       \
	0  /	       2        \
	  /	      /   \       \
  /    0 /	      \ 1    \
	/	     /	        \      \
	2(A)	 1(B) 	    1(C)    4(D)

So codes:

A - 00
B - 010
C - 011
D - 1

Collect this codes to the message. And u have to send table with codes. 


Graph: 
		
	1-----2
	|     |
	|     |
	|     |
	3-----4

Spanning tree:
	
	1------2
	|
	|
	|
	3------4

There are 2 algorithms that allow to find the least cost way from the 1 graph spike to another: 

Prims - choose the least cost way that connected to exists spikes
Kruskals - choost the least cost way that does not create circular graph

Dijkstra algorithm - allows to find shortest path from one spike of a graph to another
U get the cheapest road and at the next step get the cheapest point of the last points and get new cheapest way/ 



	



Graph Traversal (BFS & DFS)

https://www.youtube.com/watch?v=pcKY4hjDrxk&list=PLDN4rrl48XKpZkf03iYFl-O29szjTrs_O&index=61

BFS: take any vertex as first, then visit all vortexes around first vertex in any order and so on. 
DFS: take any vertex, then exporing next vertex (only 1). If next vertex does not contain children then come back to the 
previous vertex and continue the exploration of the previous vertex. 

https://www.youtube.com/watch?v=jFZsDDB0-vo&list=PLDN4rrl48XKpZkf03iYFl-O29szjTrs_O&index=62
Articulation point - if there is a vertex in a graph, which removing will disconnect graph into 2 components than that 
vertex in called an articulation point 

		
			1
		       / \
		      /   \
		     4     2
		      \    /
		       \  /
			 3 - articulation point
		        / \
		       /   \
		      7     6
		      
		      
		      
https://www.youtube.com/watch?v=dQr4wZCiJJ4&list=PLDN4rrl48XKpZkf03iYFl-O29szjTrs_O&index=67
Hamiltonial cycle -  a cycle that visit each vertex only once. There is always O(n^n), so there is no easy way to run 
thorugh the Hamiltonial cycle. Cycle does not change if u choose just another entering vertex (1, 2, 3, 1) is same to the 
(2, 3, 1, 2). Hamiltonial cycle can not exists if there is an articulation point in a graph.

Stack is used for BFS and queue for DFS

Least cost - pick node with the least cost (whereas BFS use the last node and DFS - the first in the queue)

 



In a graph it is not a desirable structure. The easies way to remove an articulation point is connect different 
vertexes with an edge (4 with 7 here, for example)

Usually DFS is used to find out an articulation point. 


Backtracking - brute force approach (try all solutions and use that one that is suitable for u)
















